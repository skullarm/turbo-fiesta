<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced WebSocket Proxy Client Demo</title>
  <style>
    body { font-family: sans-serif; background: #222; color: #eee; }
    #log { background: #111; padding: 1em; height: 300px; overflow: auto; }
    input, button, select { margin: 0.5em; }
    .cookie-list { font-size: 0.9em; color: #ccc; }
  </style>
</head>
<body>
  <h2>Advanced WebSocket Proxy Client Demo</h2>
  <label>URL: <input id="url" type="text" value="https://example.com" size="40"></label>
  <label>Method:
    <select id="method">
      <option>GET</option>
      <option>POST</option>
      <option>PUT</option>
      <option>PATCH</option>
    </select>
  </label>
  <label>Body: <input id="body" type="text" size="40"></label>
  <button onclick="sendRequest()">Send Request</button>
  <button onclick="clearLog()">Clear Log</button>
  <div class="cookie-list">Current Cookies: <span id="cookieDisplay"></span></div>
  <div id="log"></div>
  <script>
    const ws = new WebSocket('wss://turbo-fiesta.skullarm8387.workers.dev');
    const log = document.getElementById('log');
    const cookieDisplay = document.getElementById('cookieDisplay');

    function updateCookieDisplay() {
      cookieDisplay.textContent = document.cookie;
    }
    updateCookieDisplay();

    ws.onopen = () => logMsg('WebSocket connected');
    ws.onclose = () => logMsg('WebSocket closed');
    ws.onerror = e => logMsg('WebSocket error: ' + e);

    ws.onmessage = (event) => {
      let msg;
      // Try to parse as JSON, else treat as binary
      try { msg = JSON.parse(event.data); } catch { msg = event.data; }
      // Handle Set-Cookie messages
      if (msg.t === 'set-cookie' && msg.si) {
        const cookies = JSON.parse(msg.si);
        cookies.forEach(cookieStr => {
          document.cookie = cookieStr;
          logMsg('Set-Cookie: ' + cookieStr);
        });
        updateCookieDisplay();
        return;
      }
      // Display HTML response in a new window
      if (msg.c === 'text/html' && msg.d) {
        const win = window.open('', '_blank');
        win.document.write(msg.d);
        return;
      }
      // Handle streamed audio/video using MediaSource for true streaming
      if (msg.t === 's' && msg.c && (msg.c.startsWith('audio') || msg.c.startsWith('video'))) {
        logMsg('Streaming ' + msg.c + '...');
        let media, mimeType = msg.c;
        if (msg.c.startsWith('audio')) {
          media = document.createElement('audio');
        } else {
          media = document.createElement('video');
          media.width = 480;
        }
        media.controls = true;
        media.autoplay = true;
        document.body.appendChild(media);
        // MediaSource setup
        const mediaSource = new MediaSource();
        media.src = URL.createObjectURL(mediaSource);
        window._mediaSource = mediaSource;
        window._mediaElem = media;
        window._mediaQueue = [];
        window._mediaSourceBuffer = null;
        window._mediaType = mimeType;
        mediaSource.addEventListener('sourceopen', () => {
          try {
            window._mediaSourceBuffer = mediaSource.addSourceBuffer(mimeType);
            // Append any queued chunks
            window._mediaQueue.forEach(chunk => {
              window._mediaSourceBuffer.appendBuffer(chunk);
            });
            window._mediaQueue = [];
          } catch (e) {
            logMsg('MediaSource error: ' + e);
          }
        });
        return;
      }
      // Receive binary chunk (ArrayBuffer)
      if (typeof event.data !== 'string' && window._mediaSource && window._mediaType) {
        let chunk = new Uint8Array(event.data);
        if (window._mediaSource.readyState === 'open' && window._mediaSourceBuffer) {
          try {
            window._mediaSourceBuffer.appendBuffer(chunk);
          } catch (e) {
            logMsg('SourceBuffer error: ' + e);
          }
        } else {
          window._mediaQueue.push(chunk);
        }
        return;
      }
      // End of stream, signal MediaSource end
      if (msg.t === 'e' && window._mediaSource && window._mediaSource.readyState === 'open') {
        try {
          window._mediaSource.endOfStream();
          logMsg('Media stream complete.');
        } catch (e) {
          logMsg('MediaSource endOfStream error: ' + e);
        }
        window._mediaSource = null;
        window._mediaElem = null;
        window._mediaType = null;
        window._mediaSourceBuffer = null;
        window._mediaQueue = null;
        return;
      }
      logMsg('Received: ' + JSON.stringify(msg));
    };

    function sendRequest() {
      const url = document.getElementById('url').value;
      const method = document.getElementById('method').value;
      const body = document.getElementById('body').value;
      const cookie = document.cookie;
      // If requesting audio/video, set si=true for streaming
      let si = 'false';
      if (url.match(/\.(mp4|webm|mp3|wav|ogg)$/i)) si = 'true';
      const req = {
        u: url,
        a: navigator.userAgent,
        q: url,
        au: btoa(new Date().getUTCFullYear() + '' + new Date().getUTCMonth() + '' + new Date().getUTCDate()),
        method: method,
        body: body || null,
        cookie: cookie,
        si: si
      };
      ws.send(JSON.stringify(req));
      logMsg('Sent: ' + JSON.stringify(req));
    }

    function logMsg(msg) {
      log.innerHTML += msg + '<br>';
      log.scrollTop = log.scrollHeight;
    }

    function clearLog() {
      log.innerHTML = '';
    }
  </script>
</body>
</html>
