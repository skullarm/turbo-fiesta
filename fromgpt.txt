setUpMp4 = async r => {
  if (!mp4boxLoaded) await ldmp4box();

  r.mp4 = mp4box.createFile();
  r.offset = 0;
  r.sbQ = [];
  r.streamEnded = false;

  r.mp4.onReady = async info => {
    mlog('mp4box ready');

    const track = info.tracks[0];
    r.codec = track.codec;
    r.trackId = track.id;

    await setUpMSE(r);

    r.mp4.setSegmentOptions(r.trackId, null, {
      nbSamples: 30,
      rapAlignement: true
    });

    const initSegs = r.mp4.initializeSegmentation();

    // ðŸ”´ REQUIRED: append init segment FIRST
    for (const seg of initSegs) {
      r.sb.appendBuffer(seg.buffer);
    }

    r.mp4.start();
  };

  r.mp4.onSegment = (id, user, buffer) => {
    if (!r.sb) return;
    r.sbQ.push(buffer);
    if (r.sbQ.length > SEG_QUEUE_LIMIT) r.sbQ.shift();
    drainSB(r);
  };

  r.mp4.onError = err => mlog(`mp4box error: ${err}`);
};


  r.mp4.onSegment = (id, user, buffer) => {
    if (!r.sb) return;
    r.sbQ.push(buffer);
    if (r.sbQ.length > SEG_QUEUE_LIMIT) r.sbQ.shift();
    drainSB(r);
  };

  r.mp4.onError = err => mlog(`mp4box error: ${err}`);
};


setUpMSE = r => {
  return new Promise((resolve, reject) => {
    r.mse = new MediaSource();
    r.vid.src = URL.createObjectURL(r.mse);
    r.vid.controls = true;
    J(pl, r.vid);

    r.mse.addEventListener('sourceopen', () => {
      try {
        const mime = `video/mp4; codecs="${r.codec}"`;
        r.sb = r.mse.addSourceBuffer(mime);

        // ðŸ”´ REQUIRED FOR FRAGMENTED MP4
        r.sb.mode = 'sequence';

        r.sbBusy = false;

        r.sb.addEventListener('updateend', () => {
          r.sbBusy = false;
          drainSB(r);
        });

        resolve();
      } catch (e) {
        reject(e);
      }
    }, { once: true });
  });
};


processChk = (r, u8) => {
  const ab = u8.buffer.slice(
    u8.byteOffset,
    u8.byteOffset + u8.byteLength
  );

  // ðŸ”´ REQUIRED
  ab.fileStart = r.offset;
  r.offset = r.mp4.appendBuffer(ab);
};


drainSB = r => {
  if (!r.sb || r.sbBusy) return;

  if (r.streamEnded && r.sbQ.length === 0 && r.mse.readyState === 'open') {
    try { r.mse.endOfStream(); } catch {}
    return;
  }

  const seg = r.sbQ.shift();
  if (!seg) return;

  try {
    r.sbBusy = true;
    r.sb.appendBuffer(seg);
  } catch (e) {
    r.sbBusy = false;
    mlog(e);
  }
};


handleEndOfStream = q => {
  const r = p.get(q);
  if (!r) return;

  if (r.usesMSE) {
    r.streamEnded = true;
    drainSB(r);
    return;
  }

  // existing non-MSE logic unchanged
};



mp4.onReady...AUDIO
r.mp4.onReady = async info => {
  mlog('mp4box ready');

  r.tracks = info.tracks;
  r.sourceBuffers = {};
  r.sbQ = {};

  await setUpMSE(r, info);

  for (const track of info.tracks) {
    r.mp4.setSegmentOptions(track.id, null, {
      nbSamples: 30,
      rapAlignement: true
    });
  }

  const initSegs = r.mp4.initializeSegmentation();

  for (const seg of initSegs) {
    const sb = r.sourceBuffers[seg.user];
    sb.appendBuffer(seg.buffer);
  }

  r.mp4.start();
};



setUpMSE = (r, info) => {
  return new Promise((resolve, reject) => {
    r.mse = new MediaSource();
    r.vid.src = URL.createObjectURL(r.mse);
    r.vid.controls = true;
    J(pl, r.vid);

    r.mse.addEventListener('sourceopen', () => {
      try {
        for (const track of info.tracks) {
          const mime = `${track.type}/mp4; codecs="${track.codec}"`;
          const sb = r.mse.addSourceBuffer(mime);
          sb.mode = 'sequence';

          sb.addEventListener('updateend', () => {
            drainSB(r, track.id);
          });

          r.sourceBuffers[track.id] = sb;
          r.sbQ[track.id] = [];
        }
        resolve();
      } catch (e) {
        reject(e);
      }
    }, { once: true });
  });
};


r.mp4.onSegment = (trackId, user, buffer) => {
  const q = r.sbQ[trackId];
  if (!q) return;
  q.push(buffer);
  drainSB(r, trackId);
};


drainSB = (r, trackId) => {
  const sb = r.sourceBuffers[trackId];
  const q = r.sbQ[trackId];
  if (!sb || sb.updating || !q.length) return;
  sb.appendBuffer(q.shift());
};
